{
  "reference": "nocedal-wright-2006",
  "pages": "177-178",
  "algorithm": "Algorithm 7.4 (L-BFGS two-loop recursion)",
  "claim": "L-BFGS requires $O(Md)$ memory and $O(Md)$ time per iteration, where $M$ is the memory size (number of stored curvature pairs) and $d$ is the dimension",
  "quote": "To circumvent this problem, we store a modified version of $H_k$ implicitly, by storing a certain number (say, $m$) of the vector pairs $\\{s_i, y_i\\}$ used in the formulas (7.16)â€“(7.18). The product $H_k \\nabla f_k$ can be obtained by performing a sequence of inner products and vector summations involving $\\nabla f_k$ and the pairs $\\{s_i, y_i\\}$. [...] Without considering the multiplication $H_k^0 q$, the two-loop recursion scheme requires $4mn$ multiplications; if $H_k^0$ is diagonal, then $n$ additional multiplications are needed.",
  "notes": "Internal: The complexity analysis appears on page 178 following Algorithm 7.4. The key observation is that L-BFGS stores $m$ vector pairs $\\{s_i, y_i\\}$, each of length $n$ (dimension $d$ in our notation), requiring $O(mn) = O(Md)$ storage. The two-loop recursion performs $4mn$ scalar multiplications plus $n$ for the initial Hessian approximation, giving $O(mn) = O(Md)$ time complexity per iteration.",
  "readerNotes": "L-BFGS achieves its efficiency through compact storage: instead of storing a dense $d \\times d$ approximate Hessian (requiring $O(d^2)$ memory), it stores only $M$ vector pairs $\\{s_k, y_k\\}$ of dimension $d$, requiring $O(Md)$ memory. The two-loop recursion (Algorithm 7.4) computes the search direction efficiently using these stored pairs. The algorithm performs two passes through the $M$ stored pairs, with each loop iteration performing $O(d)$ operations (inner products and vector additions), yielding $O(Md)$ total time per optimization iteration. The quote states that the recursion requires $4mn$ scalar multiplications (where $m = M$ and $n = d$), plus $n$ more if the initial approximation $H_k^0$ is diagonal.",
  "proofPages": [
    "docs/references/extracted-pages/numericaloptimization2006_page_0197.png",
    "docs/references/extracted-pages/numericaloptimization2006_page_0198.png"
  ],
  "verified": "2025-11-12",
  "verifiedBy": "verification-agent",
  "verificationNotes": "Independent verification completed 2025-11-12: (1) Both quotes verified word-for-word against OCR text from pages 177-178; (2) Algorithm 7.4 correctly identified on page 178; (3) Claim accurately reflects source material - O(Md) memory for storing M vector pairs of dimension d, and O(Md) time from 4mn multiplications in two-loop recursion; (4) Usage in LbfgsTab.tsx (line 1311) is correct and appropriate; (5) Page numbers correct (printed pages 177-178, which are PDF physical pages 197-198 due to ~20 page offset from frontmatter). Citation is complete, accurate, and properly contextualized.",
  "usedIn": [
    "LbfgsTab"
  ],
  "pdfPages": "197-198",
  "formulaImages": [
    {
      "formula_id": "numericaloptimization2006_p197_equations_7_16-7_18",
      "metadata_path": "docs/references/extracted-pages/formulas/numericaloptimization2006_p197_equations_7_16-7_18.json",
      "image_path": "docs/references/extracted-pages/formulas/numericaloptimization2006_p197_equations_7_16-7_18.png",
      "latex": "H_{k+1} = V_k^T H_k V_k + \\rho_k s_k s_k^T \\quad (7.16)\n\n\\text{where } \\rho_k = \\frac{1}{y_k^T s_k}, \\quad V_k = I - \\rho_k y_k s_k^T \\quad (7.17)\n\n\\text{and } s_k = x_{k+1} - x_k, \\quad y_k = \\nabla f_{k+1} - \\nabla f_k \\quad (7.18)",
      "verified": true,
      "theorem": "Equations 7.16-7.18",
      "equation": "(7.16)-(7.18)",
      "page": 197
    },
    {
      "formula_id": "numericaloptimization2006_p198_algorithm_7_4",
      "metadata_path": "docs/references/extracted-pages/formulas/numericaloptimization2006_p198_algorithm_7_4.json",
      "image_path": "docs/references/extracted-pages/formulas/numericaloptimization2006_p198_algorithm_7_4.png",
      "latex": "\\begin{algorithm}\n\\caption{Algorithm 7.4 (L-BFGS two-loop recursion)}\n\\begin{algorithmic}\n\\State $q \\gets \\nabla f_k$\n\\For{$i = k-1, k-2, \\ldots, k-m$}\n  \\State $\\alpha_i \\gets \\rho_i s_i^T q$\n  \\State $q \\gets q - \\alpha_i y_i$\n\\EndFor\n\\State $r \\gets H_k^0 q$\n\\For{$i = k-m, k-m+1, \\ldots, k-1$}\n  \\State $\\beta \\gets \\rho_i y_i^T r$\n  \\State $r \\gets r + s_i(\\alpha_i - \\beta)$\n\\EndFor\n\\State \\textbf{stop with result} $H_k \\nabla f_k = r$\n\\end{algorithmic}\n\\end{algorithm}",
      "verified": true,
      "theorem": "Algorithm 7.4",
      "equation": "L-BFGS two-loop recursion",
      "page": 198
    },
    {
      "formula_id": "numericaloptimization2006_p198_complexity_analysis",
      "metadata_path": "docs/references/extracted-pages/formulas/numericaloptimization2006_p198_complexity_analysis.json",
      "image_path": "docs/references/extracted-pages/formulas/numericaloptimization2006_p198_complexity_analysis.png",
      "latex": "\\text{Without considering the multiplication } H_k^0 q, \\text{ the two-loop recursion scheme requires } 4mn \\text{ multiplications; if } H_k^0 \\text{ is diagonal, then } n \\text{ additional multiplications are needed.}",
      "verified": true,
      "theorem": "Complexity Analysis",
      "equation": "O(md) complexity statement",
      "page": 198
    }
  ]
}