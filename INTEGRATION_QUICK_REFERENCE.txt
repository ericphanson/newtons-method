================================================================================
NEWTON'S METHOD CODEBASE: PROBLEM INTEGRATION MAP
================================================================================

PROBLEM TYPES (6 total):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

2D Pure Optimization (in Registry):
  1. Quadratic Bowl [w0^2 + w1^2] (θ parametrized)
  2. Ill-Conditioned Quadratic [w0^2 + κ*w1^2] (κ parametrized)
  3. Rosenbrock Function [non-convex banana] (b parametrized)
  4. Saddle Point [w0^2 - w1^2] (no parameters)

3D Dataset-based (dynamic):
  5. Logistic Regression [binary classification + L2 reg]
  6. Separating Hyperplane [3 variants: soft-margin, perceptron, squared-hinge]

KEY FILE LOCATIONS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Problem Definitions:
  /src/problems/index.ts ..................... Problem registry + getProblem()
  /src/problems/quadratic.ts ................ Quadratic and ill-conditioned
  /src/problems/rosenbrock.ts ............... Rosenbrock factory
  /src/problems/saddle.ts ................... Saddle point
  /src/utils/logisticRegression.ts ......... Logistic regression functions
  /src/utils/separatingHyperplane.ts ....... SVM variants

Problem Configuration:
  /src/types/experiments.ts ................. ProblemType union + ProblemDefinition interface
  /src/utils/problemDefaults.ts ............ Default parameters per problem
  /src/utils/problemAdapter.ts ............. Adapters for algorithms

UI Components:
  /src/components/ProblemConfiguration.tsx . Problem dropdown + parameters
  /src/components/ProblemExplainer.tsx .... Documentation modal
  /src/components/BasinPicker.tsx ......... Basin visualization
  /src/UnifiedVisualizer.tsx .............. Main integrator (getCurrentProblem*, algorithms)

Basin & Visualization:
  /src/utils/basinComputation.ts ......... Basin point + incremental computation
  /src/utils/basinColorEncoding.ts ....... Color mapping for basins
  /src/utils/contourDrawing.ts ........... Contour plot rendering

Experiments:
  /src/experiments/index.ts .............. Preset registry
  /src/experiments/*-presets.ts ......... Algorithm-specific presets

Validation:
  /python/problems.py .................... Python parallel implementations

PROBLEM INTEGRATION INTERFACE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Core Interface (ProblemDefinition):
  ┌─────────────────────────────────────────────────────────────┐
  │ interface ProblemDefinition {                               │
  │   name: string;                   // "Quadratic Bowl"       │
  │   description: string;            // Technical details      │
  │   objective: (w: number[]) => number;   // f(w)            │
  │   gradient: (w: number[]) => number[];  // ∇f(w)           │
  │   hessian?: (w: number[]) => number[][]; // H(w) [optional] │
  │   domain: { w0: [min, max]; w1: [min, max] };             │
  │   globalMinimum?: [number, number];                         │
  │   criticalPoint?: [number, number];                         │
  │ }                                                           │
  └─────────────────────────────────────────────────────────────┘

Algorithm Interface (ProblemFunctions):
  ┌─────────────────────────────────────────────────────────────┐
  │ interface ProblemFunctions {                                │
  │   objective: (w: number[]) => number;                       │
  │   gradient: (w: number[]) => number[];                      │
  │   hessian?: (w: number[]) => number[][];                    │
  │   dimensionality: 2 | 3;  // For 2D or 3D problems         │
  │ }                                                           │
  └─────────────────────────────────────────────────────────────┘

TYPE SYSTEM:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ProblemType (src/types/experiments.ts):
  'quadratic'
  'ill-conditioned-quadratic'
  'rosenbrock'
  'non-convex-saddle'
  'logistic-regression'
  'separating-hyperplane'

INTEGRATION CHECKLIST: ADDING A NEW PROBLEM
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[1] Core Implementation
    [ ] Create /src/problems/my-problem.ts
    [ ] Export ProblemDefinition instance
    [ ] Implement: objective, gradient, hessian, domain, globalMinimum?

[2] Registration
    [ ] Add to problemRegistry in /src/problems/index.ts
    [ ] Add to ProblemType union in /src/types/experiments.ts

[3] Configuration
    [ ] Add defaults in /src/utils/problemDefaults.ts (getProblemDefaults)
    [ ] Add note in /src/utils/problemDefaults.ts (getProblemNote)

[4] UI Integration
    [ ] Add option to dropdown in ProblemConfiguration.tsx
    [ ] Add problem-specific parameters section (if needed)
    [ ] Import in UnifiedVisualizer.tsx (if factory function)

[5] Main Visualizer
    [ ] Update getCurrentProblem() in UnifiedVisualizer.tsx
    [ ] Update getCurrentProblemFunctions() in UnifiedVisualizer.tsx

[6] Documentation
    [ ] Add to ProblemExplainer.tsx

[7] Validation
    [ ] Add Python version in /python/problems.py
    [ ] Test all algorithms (GD, GD-LS, Newton, L-BFGS)
    [ ] Verify gradient numerically
    [ ] Verify Hessian numerically

[8] Optional
    [ ] Create experiment presets in /src/experiments/
    [ ] Register presets in /src/experiments/index.ts

CRITICAL INTEGRATION POINTS IN UnifiedVisualizer.tsx:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Problem Type State
   const [currentProblem, setCurrentProblem] = useState<string>('logistic-regression');

2. Problem Parameters (if needed)
   const [rotationAngle, setRotationAngle] = useState(0);
   const [conditionNumber, setConditionNumber] = useState(100);
   const [rosenbrockB, setRosenbrockB] = useState(100);
   const [separatingHyperplaneVariant, setSeparatingHyperplaneVariant] = useState('soft-margin');

3. Problem Definition Function (lines 140-209)
   const getCurrentProblem = useCallback(() => {
     if (currentProblem === 'logistic-regression') { ... }
     else if (currentProblem === 'quadratic') { ... }
     else if (currentProblem === 'ill-conditioned-quadratic') { ... }
     else if (currentProblem === 'rosenbrock') { ... }
     else if (currentProblem === 'separating-hyperplane') { ... }
     else { const problem = getProblem(currentProblem); ... }
   }, [currentProblem, data, lambda, rotationAngle, conditionNumber, rosenbrockB, separatingHyperplaneVariant]);

4. Algorithm Interface Function (lines 214-241)
   const getCurrentProblemFunctions = useCallback((): ProblemFunctions => {
     // Same logic as getCurrentProblem but adapted for algorithms
   }, [currentProblem, data, lambda, rotationAngle, conditionNumber, rosenbrockB, separatingHyperplaneVariant]);

5. Algorithm Execution Dependencies
   Algorithm useEffects depend on:
     - [currentProblem, lambda, ... parameters ..., getCurrentProblemFunctions]
   When currentProblem or parameters change → algorithms recompute automatically

PROBLEM CHARACTERISTICS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Problem              | Dims | Convex | Factory? | Params | Default Init     | Key Learning
──────────────────────────────────────────────────────────────────────────────────────────
Quadratic            | 2D   | Yes    | Yes      | θ      | [-3, 3]          | Rotation invariance
Ill-Cond Quadratic   | 2D   | Yes    | Yes      | κ      | [-2, 2]          | Condition number effect
Rosenbrock           | 2D   | No     | Yes      | b      | [-0.5, 1.5]      | Steep gradient valleys
Saddle Point         | 2D   | No     | No       | —      | [-1.5, 1.5]      | Negative Hessian eigenvalues
Logistic Regression  | 3D   | Yes    | No*      | λ      | [0, 0, 0]        | Dataset-dependent
Sep. Hyperplane      | 3D   | Mixed* | No*      | λ,var  | [0.2, 0.2, 0]    | Different loss functions

* = Dynamic creation; var = soft-margin|perceptron|squared-hinge

DIMENSIONALITY HANDLING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

2D Problems (Pure Optimization):
  - Initial point: [w0, w1]
  - Visualization: Full 2D parameter space
  - Basin: 20x20 grid in 2D
  - ProblemFunctions.dimensionality = 2

3D Problems (Dataset-based):
  - Initial point: [w0, w1, bias]
  - Visualization: 2D slice at fixed bias value
  - Basin: 2D grid slice (bias from algorithm params)
  - ProblemFunctions.dimensionality = 3
  - Special handling in BasinPicker.tsx:
    if (dimensionality === 3)
      onInitialPointChange([w0, w1, algorithmParams.biasSlice || 0]);

EXAMPLE: ADDING A "SIMPLE CUBIC" PROBLEM
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. File: /src/problems/cubic.ts
   ─────────────────────────────
   import { ProblemDefinition } from '../types/experiments';
   
   export const cubicProblem: ProblemDefinition = {
     name: 'Simple Cubic',
     description: 'f(w) = w0^3 - 3*w0 + w1^2 (saddle-like behavior)',
     objective: (w: number[]): number => {
       const [w0, w1] = w;
       return w0**3 - 3*w0 + w1*w1;
     },
     gradient: (w: number[]): number[] => {
       const [w0, w1] = w;
       return [3*w0*w0 - 3, 2*w1];
     },
     hessian: (w: number[]): number[][] => {
       const [w0, w1] = w;
       return [[6*w0, 0], [0, 2]];
     },
     domain: { w0: [-2, 2], w1: [-2, 2] },
     globalMinimum: [1, 0],
   };

2. File: /src/problems/index.ts
   ────────────────────────────
   import { cubicProblem } from './cubic';
   
   export const problemRegistry = {
     // ... existing ...
     'cubic': cubicProblem,
   };

3. File: /src/types/experiments.ts
   ───────────────────────────────
   export type ProblemType = 
     | 'logistic-regression'
     | 'quadratic'
     | 'ill-conditioned-quadratic'
     | 'rosenbrock'
     | 'non-convex-saddle'
     | 'separating-hyperplane'
     | 'cubic';  // ADD HERE

4. File: /src/utils/problemDefaults.ts
   ──────────────────────────────────
   export function getProblemDefaults(problem: string) {
     switch (problem) {
       // ... existing ...
       case 'cubic':
         return {
           gdFixedAlpha: 0.01,
           maxIter: 200,
           initialPoint: [-1.5, 1.5],
           c1: 0.0001,
           lbfgsM: 5
         };
     }
   }
   
   export function getProblemNote(problem: string) {
     switch (problem) {
       // ... existing ...
       case 'cubic':
         return 'Cubic with saddle-like behavior - test algorithm robustness';
     }
   }

5. File: /src/components/ProblemConfiguration.tsx
   ────────────────────────────────────────────────
   <option value="cubic">Simple Cubic</option>

6. File: /src/UnifiedVisualizer.tsx
   ─────────────────────────────────
   import { getProblem, createRotatedQuadratic, ..., cubicProblem } from './problems';
   
   // In getCurrentProblem():
   } else if (currentProblem === 'cubic') {
     const problem = getProblem('cubic');
     return { ...problem, dimensionality: 2 };
   }
   
   // In getCurrentProblemFunctions():
   } else if (currentProblem === 'cubic') {
     const problem = getProblem('cubic');
     return problemToProblemFunctions(problem);
   }

7. File: /src/components/ProblemExplainer.tsx
   ──────────────────────────────────────────
   Add section:
   <div>
     <h4>Simple Cubic</h4>
     <p>f(w) = w₀³ - 3w₀ + w₁²</p>
     <p>Combines cubic behavior in w₀ with quadratic in w₁...</p>
   </div>

8. File: /python/problems.py (optional)
   ──────────────────────────────────────
   def cubic() -> Problem:
       def objective(w: np.ndarray) -> float:
           return w[0]**3 - 3*w[0] + w[1]**2
       def gradient(w: np.ndarray) -> np.ndarray:
           return np.array([3*w[0]**2 - 3, 2*w[1]])
       def hessian(w: np.ndarray) -> np.ndarray:
           return np.array([[6*w[0], 0], [0, 2]])
       return Problem("cubic", objective, gradient, hessian)

DONE! Now "cubic" appears in dropdown and works with all 4 algorithms + basin visualization.

================================================================================
